/*
 * Cart-Api v2
 *
 * A Microsoft WebApi2 application. For use by Jeunesse and its Partners, this api has a focus on product and order creation
 *
 * API version: v2
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package cart_v2

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type ProductApiService service

/*
ProductApiService Returns a list of top 5 best selling products.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetBestSellersOpts - Optional Parameters:
     * @param "CartKey" (optional.Interface of string) -
     * @param "ProductsToShow" (optional.String) -
     * @param "Limit" (optional.Int32) -
     * @param "CartType" (optional.String) -
     * @param "CountryCode" (optional.String) -
     * @param "Culture" (optional.String) -

@return []BestSellersViewModel
*/

type ProductApiProductGetBestSellersOpts struct {
	CartKey        optional.Interface
	ProductsToShow optional.String
	Limit          optional.Int32
	CartType       optional.String
	CountryCode    optional.String
	Culture        optional.String
}

func (a *ProductApiService) ProductGetBestSellers(ctx context.Context, localVarOptionals *ProductApiProductGetBestSellersOpts) ([]BestSellersViewModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []BestSellersViewModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/best-sellers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CartKey.IsSet() {
		localVarQueryParams.Add("cartKey", parameterToString(localVarOptionals.CartKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProductsToShow.IsSet() {
		localVarQueryParams.Add("productsToShow", parameterToString(localVarOptionals.ProductsToShow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CartType.IsSet() {
		localVarQueryParams.Add("cartType", parameterToString(localVarOptionals.CartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CountryCode.IsSet() {
		localVarQueryParams.Add("countryCode", parameterToString(localVarOptionals.CountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Culture.IsSet() {
		localVarQueryParams.Add("culture", parameterToString(localVarOptionals.Culture.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []BestSellersViewModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Returns a list of best selling products.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetBestsellersOpts - Optional Parameters:
     * @param "ModelCartKey" (optional.Interface of string) -
     * @param "ModelProductsToShow" (optional.String) -
     * @param "ModelLimit" (optional.Int32) -
     * @param "ModelCartType" (optional.String) -
     * @param "ModelCountryCode" (optional.String) -
     * @param "ModelCulture" (optional.String) -

@return []FullProductViewModel
*/

type ProductApiProductGetBestsellersOpts struct {
	ModelCartKey        optional.Interface
	ModelProductsToShow optional.String
	ModelLimit          optional.Int32
	ModelCartType       optional.String
	ModelCountryCode    optional.String
	ModelCulture        optional.String
}

func (a *ProductApiService) ProductGetBestsellers(ctx context.Context, localVarOptionals *ProductApiProductGetBestsellersOpts) ([]FullProductViewModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []FullProductViewModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/bestseller"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ModelCartKey.IsSet() {
		localVarQueryParams.Add("model.cartKey", parameterToString(localVarOptionals.ModelCartKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModelProductsToShow.IsSet() {
		localVarQueryParams.Add("model.productsToShow", parameterToString(localVarOptionals.ModelProductsToShow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModelLimit.IsSet() {
		localVarQueryParams.Add("model.limit", parameterToString(localVarOptionals.ModelLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModelCartType.IsSet() {
		localVarQueryParams.Add("model.cartType", parameterToString(localVarOptionals.ModelCartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModelCountryCode.IsSet() {
		localVarQueryParams.Add("model.countryCode", parameterToString(localVarOptionals.ModelCountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModelCulture.IsSet() {
		localVarQueryParams.Add("model.culture", parameterToString(localVarOptionals.ModelCulture.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []FullProductViewModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Gets a list of products that have been selected to spotlight
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetBrandSpotlightOpts - Optional Parameters:
     * @param "CartKey" (optional.Interface of string) -
     * @param "ProductsToShow" (optional.String) -
     * @param "Limit" (optional.Int32) -
     * @param "CartType" (optional.String) -
     * @param "CountryCode" (optional.String) -
     * @param "Culture" (optional.String) -

@return []BrandViewModel
*/

type ProductApiProductGetBrandSpotlightOpts struct {
	CartKey        optional.Interface
	ProductsToShow optional.String
	Limit          optional.Int32
	CartType       optional.String
	CountryCode    optional.String
	Culture        optional.String
}

func (a *ProductApiService) ProductGetBrandSpotlight(ctx context.Context, localVarOptionals *ProductApiProductGetBrandSpotlightOpts) ([]BrandViewModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []BrandViewModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/brand/best-sellers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CartKey.IsSet() {
		localVarQueryParams.Add("cartKey", parameterToString(localVarOptionals.CartKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProductsToShow.IsSet() {
		localVarQueryParams.Add("productsToShow", parameterToString(localVarOptionals.ProductsToShow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CartType.IsSet() {
		localVarQueryParams.Add("cartType", parameterToString(localVarOptionals.CartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CountryCode.IsSet() {
		localVarQueryParams.Add("countryCode", parameterToString(localVarOptionals.CountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Culture.IsSet() {
		localVarQueryParams.Add("culture", parameterToString(localVarOptionals.Culture.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []BrandViewModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Returns a headers for CAP with CV ranges
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param country Country
  - @param langId LangId

@return []CapHeaderModel
*/
func (a *ProductApiService) ProductGetCAPHeadersWithCVRanges(ctx context.Context, country string, langId int32) ([]CapHeaderModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []CapHeaderModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/cap-headers/{country}/{langId}"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", fmt.Sprintf("%v", country), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"langId"+"}", fmt.Sprintf("%v", langId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []CapHeaderModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Get a listing of all available categories
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetCategoriesOpts - Optional Parameters:
     * @param "CartType" (optional.String) -
     * @param "CountryCode" (optional.String) -
     * @param "Culture" (optional.String) -

@return []CategoryModel
*/

type ProductApiProductGetCategoriesOpts struct {
	CartType    optional.String
	CountryCode optional.String
	Culture     optional.String
}

func (a *ProductApiService) ProductGetCategories(ctx context.Context, localVarOptionals *ProductApiProductGetCategoriesOpts) ([]CategoryModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []CategoryModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CartType.IsSet() {
		localVarQueryParams.Add("cartType", parameterToString(localVarOptionals.CartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CountryCode.IsSet() {
		localVarQueryParams.Add("countryCode", parameterToString(localVarOptionals.CountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Culture.IsSet() {
		localVarQueryParams.Add("culture", parameterToString(localVarOptionals.Culture.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []CategoryModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Get specific category information
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param categoryId Product Category PK

@return CategoryModel
*/
func (a *ProductApiService) ProductGetCategoryById(ctx context.Context, categoryId int32) (CategoryModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CategoryModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/categories/{categoryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"categoryId"+"}", fmt.Sprintf("%v", categoryId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CategoryModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Returns a list of may love products
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param suggestProductQueryProductPK
 * @param optional nil or *ProductApiProductGetMayLoveProductsOpts - Optional Parameters:
     * @param "SuggestProductQueryCartType" (optional.String) -
     * @param "SuggestProductQueryCountryCode" (optional.String) -
     * @param "SuggestProductQueryLanguagePK" (optional.Int32) -

@return []SuggestProductModel
*/

type ProductApiProductGetMayLoveProductsOpts struct {
	SuggestProductQueryCartType    optional.String
	SuggestProductQueryCountryCode optional.String
	SuggestProductQueryLanguagePK  optional.Int32
}

func (a *ProductApiService) ProductGetMayLoveProducts(ctx context.Context, suggestProductQueryProductPK int32, localVarOptionals *ProductApiProductGetMayLoveProductsOpts) ([]SuggestProductModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []SuggestProductModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/may-love"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SuggestProductQueryCartType.IsSet() {
		localVarQueryParams.Add("suggestProductQuery.cartType", parameterToString(localVarOptionals.SuggestProductQueryCartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SuggestProductQueryCountryCode.IsSet() {
		localVarQueryParams.Add("suggestProductQuery.countryCode", parameterToString(localVarOptionals.SuggestProductQueryCountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SuggestProductQueryLanguagePK.IsSet() {
		localVarQueryParams.Add("suggestProductQuery.languagePK", parameterToString(localVarOptionals.SuggestProductQueryLanguagePK.Value(), ""))
	}
	localVarQueryParams.Add("suggestProductQuery.productPK", parameterToString(suggestProductQueryProductPK, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []SuggestProductModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Extract all product brands
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return []ProductBrand
*/
func (a *ProductApiService) ProductGetProductBrands(ctx context.Context) ([]ProductBrand, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []ProductBrand
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/brands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []ProductBrand
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Get specific product information
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param productFk Product PK
  - @param cartType Cart Type
  - @param culture Culture

@return FullProductViewModel
*/
func (a *ProductApiService) ProductGetProductById(ctx context.Context, productFk int32, cartType string, culture string) (FullProductViewModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue FullProductViewModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/{productFk}/{cartType}/{culture}"
	localVarPath = strings.Replace(localVarPath, "{"+"productFk"+"}", fmt.Sprintf("%v", productFk), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cartType"+"}", fmt.Sprintf("%v", cartType), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"culture"+"}", fmt.Sprintf("%v", culture), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v FullProductViewModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Get specific product information
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetProductById_1Opts - Optional Parameters:
     * @param "ProductPK" (optional.Int32) -
     * @param "CountryCode" (optional.String) -
     * @param "Culture" (optional.String) -
     * @param "CartType" (optional.String) -
     * @param "MainFK" (optional.Int32) -
     * @param "RepSiteUrl" (optional.String) -
     * @param "LanguageId" (optional.Int32) -

@return FullProductViewModel
*/

type ProductApiProductGetProductById_1Opts struct {
	ProductPK   optional.Int32
	CountryCode optional.String
	Culture     optional.String
	CartType    optional.String
	MainFK      optional.Int32
	RepSiteUrl  optional.String
	LanguageId  optional.Int32
}

func (a *ProductApiService) ProductGetProductById_1(ctx context.Context, localVarOptionals *ProductApiProductGetProductById_1Opts) (FullProductViewModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue FullProductViewModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ProductPK.IsSet() {
		localVarQueryParams.Add("productPK", parameterToString(localVarOptionals.ProductPK.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CountryCode.IsSet() {
		localVarQueryParams.Add("countryCode", parameterToString(localVarOptionals.CountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Culture.IsSet() {
		localVarQueryParams.Add("culture", parameterToString(localVarOptionals.Culture.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CartType.IsSet() {
		localVarQueryParams.Add("cartType", parameterToString(localVarOptionals.CartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MainFK.IsSet() {
		localVarQueryParams.Add("mainFK", parameterToString(localVarOptionals.MainFK.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepSiteUrl.IsSet() {
		localVarQueryParams.Add("repSiteUrl", parameterToString(localVarOptionals.RepSiteUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LanguageId.IsSet() {
		localVarQueryParams.Add("languageId", parameterToString(localVarOptionals.LanguageId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v FullProductViewModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Returns a list of functions/purposes for available products
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetProductFunctionsOpts - Optional Parameters:
     * @param "CartType" (optional.String) -
     * @param "CountryCode" (optional.String) -
     * @param "Culture" (optional.String) -

@return []BrandViewModel
*/

type ProductApiProductGetProductFunctionsOpts struct {
	CartType    optional.String
	CountryCode optional.String
	Culture     optional.String
}

func (a *ProductApiService) ProductGetProductFunctions(ctx context.Context, localVarOptionals *ProductApiProductGetProductFunctionsOpts) ([]BrandViewModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []BrandViewModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/functions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CartType.IsSet() {
		localVarQueryParams.Add("cartType", parameterToString(localVarOptionals.CartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CountryCode.IsSet() {
		localVarQueryParams.Add("countryCode", parameterToString(localVarOptionals.CountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Culture.IsSet() {
		localVarQueryParams.Add("culture", parameterToString(localVarOptionals.Culture.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []BrandViewModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Get full listing of all products
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetProductsOpts - Optional Parameters:
     * @param "CartType" (optional.String) -
     * @param "RepSiteUrl" (optional.String) -
     * @param "MainOrderTypeFk" (optional.Int32) -
     * @param "MainTypeFk" (optional.Int32) -
     * @param "CountryCode" (optional.String) -
     * @param "EventId" (optional.Int32) -
     * @param "CategoryId" (optional.Int32) -
     * @param "OtherCategoryId" (optional.Int32) -
     * @param "Culture" (optional.String) -
     * @param "BrandId" (optional.Int32) -
     * @param "MenuId" (optional.Int32) -
     * @param "FunctionId" (optional.Int32) -
     * @param "LineId" (optional.Int32) -
     * @param "Take" (optional.Int32) -
     * @param "Skip" (optional.Int32) -
     * @param "SearchTerm" (optional.String) -
     * @param "IncludePromos" (optional.Bool) -
     * @param "IsRedemption" (optional.Bool) -
     * @param "MainPK" (optional.Int32) -
     * @param "ProductPK" (optional.Int32) -
     * @param "Sku" (optional.String) -
     * @param "PriceListPK" (optional.Int32) -
     * @param "IsASEligible" (optional.Bool) -
     * @param "IsPPASEligible" (optional.Bool) -
     * @param "IsAdminEligible" (optional.Bool) -
     * @param "IsSignupEligible" (optional.Bool) -
     * @param "IsSignupPackage" (optional.Bool) -
     * @param "IsStarterKit" (optional.Bool) -
     * @param "IsCreateAPack" (optional.Bool) -
     * @param "IsImportEligible" (optional.Bool) -
     * @param "IsPayCard" (optional.Bool) -
     * @param "IsCart" (optional.Bool) -
     * @param "CurrencyCode" (optional.String) -

@return []FullProductViewModel
*/

type ProductApiProductGetProductsOpts struct {
	CartType         optional.String
	RepSiteUrl       optional.String
	MainOrderTypeFk  optional.Int32
	MainTypeFk       optional.Int32
	CountryCode      optional.String
	EventId          optional.Int32
	CategoryId       optional.Int32
	OtherCategoryId  optional.Int32
	Culture          optional.String
	BrandId          optional.Int32
	MenuId           optional.Int32
	FunctionId       optional.Int32
	LineId           optional.Int32
	Take             optional.Int32
	Skip             optional.Int32
	SearchTerm       optional.String
	IncludePromos    optional.Bool
	IsRedemption     optional.Bool
	MainPK           optional.Int32
	ProductPK        optional.Int32
	Sku              optional.String
	PriceListPK      optional.Int32
	IsASEligible     optional.Bool
	IsPPASEligible   optional.Bool
	IsAdminEligible  optional.Bool
	IsSignupEligible optional.Bool
	IsSignupPackage  optional.Bool
	IsStarterKit     optional.Bool
	IsCreateAPack    optional.Bool
	IsImportEligible optional.Bool
	IsPayCard        optional.Bool
	IsCart           optional.Bool
	CurrencyCode     optional.String
}

func (a *ProductApiService) ProductGetProducts(ctx context.Context, localVarOptionals *ProductApiProductGetProductsOpts) ([]FullProductViewModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []FullProductViewModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CartType.IsSet() {
		localVarQueryParams.Add("cartType", parameterToString(localVarOptionals.CartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepSiteUrl.IsSet() {
		localVarQueryParams.Add("repSiteUrl", parameterToString(localVarOptionals.RepSiteUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MainOrderTypeFk.IsSet() {
		localVarQueryParams.Add("mainOrderTypeFk", parameterToString(localVarOptionals.MainOrderTypeFk.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MainTypeFk.IsSet() {
		localVarQueryParams.Add("mainTypeFk", parameterToString(localVarOptionals.MainTypeFk.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CountryCode.IsSet() {
		localVarQueryParams.Add("countryCode", parameterToString(localVarOptionals.CountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventId.IsSet() {
		localVarQueryParams.Add("eventId", parameterToString(localVarOptionals.EventId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CategoryId.IsSet() {
		localVarQueryParams.Add("categoryId", parameterToString(localVarOptionals.CategoryId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OtherCategoryId.IsSet() {
		localVarQueryParams.Add("otherCategoryId", parameterToString(localVarOptionals.OtherCategoryId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Culture.IsSet() {
		localVarQueryParams.Add("culture", parameterToString(localVarOptionals.Culture.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BrandId.IsSet() {
		localVarQueryParams.Add("brandId", parameterToString(localVarOptionals.BrandId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MenuId.IsSet() {
		localVarQueryParams.Add("menuId", parameterToString(localVarOptionals.MenuId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FunctionId.IsSet() {
		localVarQueryParams.Add("functionId", parameterToString(localVarOptionals.FunctionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LineId.IsSet() {
		localVarQueryParams.Add("lineId", parameterToString(localVarOptionals.LineId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Take.IsSet() {
		localVarQueryParams.Add("take", parameterToString(localVarOptionals.Take.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Skip.IsSet() {
		localVarQueryParams.Add("skip", parameterToString(localVarOptionals.Skip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchTerm.IsSet() {
		localVarQueryParams.Add("searchTerm", parameterToString(localVarOptionals.SearchTerm.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludePromos.IsSet() {
		localVarQueryParams.Add("includePromos", parameterToString(localVarOptionals.IncludePromos.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsRedemption.IsSet() {
		localVarQueryParams.Add("isRedemption", parameterToString(localVarOptionals.IsRedemption.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MainPK.IsSet() {
		localVarQueryParams.Add("mainPK", parameterToString(localVarOptionals.MainPK.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProductPK.IsSet() {
		localVarQueryParams.Add("productPK", parameterToString(localVarOptionals.ProductPK.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sku.IsSet() {
		localVarQueryParams.Add("sku", parameterToString(localVarOptionals.Sku.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PriceListPK.IsSet() {
		localVarQueryParams.Add("priceListPK", parameterToString(localVarOptionals.PriceListPK.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsASEligible.IsSet() {
		localVarQueryParams.Add("isASEligible", parameterToString(localVarOptionals.IsASEligible.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsPPASEligible.IsSet() {
		localVarQueryParams.Add("isPPASEligible", parameterToString(localVarOptionals.IsPPASEligible.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsAdminEligible.IsSet() {
		localVarQueryParams.Add("isAdminEligible", parameterToString(localVarOptionals.IsAdminEligible.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsSignupEligible.IsSet() {
		localVarQueryParams.Add("isSignupEligible", parameterToString(localVarOptionals.IsSignupEligible.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsSignupPackage.IsSet() {
		localVarQueryParams.Add("isSignupPackage", parameterToString(localVarOptionals.IsSignupPackage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsStarterKit.IsSet() {
		localVarQueryParams.Add("isStarterKit", parameterToString(localVarOptionals.IsStarterKit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsCreateAPack.IsSet() {
		localVarQueryParams.Add("isCreateAPack", parameterToString(localVarOptionals.IsCreateAPack.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsImportEligible.IsSet() {
		localVarQueryParams.Add("isImportEligible", parameterToString(localVarOptionals.IsImportEligible.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsPayCard.IsSet() {
		localVarQueryParams.Add("isPayCard", parameterToString(localVarOptionals.IsPayCard.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsCart.IsSet() {
		localVarQueryParams.Add("isCart", parameterToString(localVarOptionals.IsCart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CurrencyCode.IsSet() {
		localVarQueryParams.Add("currencyCode", parameterToString(localVarOptionals.CurrencyCode.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []FullProductViewModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Get remaining product quantities
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetRemainingProductQuantitiesOpts - Optional Parameters:
     * @param "ModelProductIds" (optional.String) -
     * @param "ModelMainPK" (optional.Int32) -

@return []RemainingProductQuantitiesModel
*/

type ProductApiProductGetRemainingProductQuantitiesOpts struct {
	ModelProductIds optional.String
	ModelMainPK     optional.Int32
}

func (a *ProductApiService) ProductGetRemainingProductQuantities(ctx context.Context, localVarOptionals *ProductApiProductGetRemainingProductQuantitiesOpts) ([]RemainingProductQuantitiesModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []RemainingProductQuantitiesModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/remaining-products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ModelProductIds.IsSet() {
		localVarQueryParams.Add("model.productIds", parameterToString(localVarOptionals.ModelProductIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModelMainPK.IsSet() {
		localVarQueryParams.Add("model.mainPK", parameterToString(localVarOptionals.ModelMainPK.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []RemainingProductQuantitiesModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Get remaining sign up product quantities
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetRemainingSignUpProductQuantitiesOpts - Optional Parameters:
     * @param "ModelProductIds" (optional.String) -
     * @param "ModelMainPK" (optional.Int32) -

@return []RemainingProductQuantitiesModel
*/

type ProductApiProductGetRemainingSignUpProductQuantitiesOpts struct {
	ModelProductIds optional.String
	ModelMainPK     optional.Int32
}

func (a *ProductApiService) ProductGetRemainingSignUpProductQuantities(ctx context.Context, localVarOptionals *ProductApiProductGetRemainingSignUpProductQuantitiesOpts) ([]RemainingProductQuantitiesModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []RemainingProductQuantitiesModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/remaining-signup-products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ModelProductIds.IsSet() {
		localVarQueryParams.Add("model.productIds", parameterToString(localVarOptionals.ModelProductIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModelMainPK.IsSet() {
		localVarQueryParams.Add("model.mainPK", parameterToString(localVarOptionals.ModelMainPK.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []RemainingProductQuantitiesModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Returns a list of ritual products
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param suggestProductQueryProductPK
 * @param optional nil or *ProductApiProductGetRitualProductsOpts - Optional Parameters:
     * @param "SuggestProductQueryCartType" (optional.String) -
     * @param "SuggestProductQueryCountryCode" (optional.String) -
     * @param "SuggestProductQueryLanguagePK" (optional.Int32) -

@return []SuggestProductModel
*/

type ProductApiProductGetRitualProductsOpts struct {
	SuggestProductQueryCartType    optional.String
	SuggestProductQueryCountryCode optional.String
	SuggestProductQueryLanguagePK  optional.Int32
}

func (a *ProductApiService) ProductGetRitualProducts(ctx context.Context, suggestProductQueryProductPK int32, localVarOptionals *ProductApiProductGetRitualProductsOpts) ([]SuggestProductModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []SuggestProductModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/ritual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SuggestProductQueryCartType.IsSet() {
		localVarQueryParams.Add("suggestProductQuery.cartType", parameterToString(localVarOptionals.SuggestProductQueryCartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SuggestProductQueryCountryCode.IsSet() {
		localVarQueryParams.Add("suggestProductQuery.countryCode", parameterToString(localVarOptionals.SuggestProductQueryCountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SuggestProductQueryLanguagePK.IsSet() {
		localVarQueryParams.Add("suggestProductQuery.languagePK", parameterToString(localVarOptionals.SuggestProductQueryLanguagePK.Value(), ""))
	}
	localVarQueryParams.Add("suggestProductQuery.productPK", parameterToString(suggestProductQueryProductPK, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []SuggestProductModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Returns a list of ritual products.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetRitualsOpts - Optional Parameters:
     * @param "ModelCartType" (optional.String) -
     * @param "ModelCountryCode" (optional.String) -
     * @param "ModelCulture" (optional.String) -

@return []FullProductViewModel
*/

type ProductApiProductGetRitualsOpts struct {
	ModelCartType    optional.String
	ModelCountryCode optional.String
	ModelCulture     optional.String
}

func (a *ProductApiService) ProductGetRituals(ctx context.Context, localVarOptionals *ProductApiProductGetRitualsOpts) ([]FullProductViewModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []FullProductViewModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/all-rituals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ModelCartType.IsSet() {
		localVarQueryParams.Add("model.cartType", parameterToString(localVarOptionals.ModelCartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModelCountryCode.IsSet() {
		localVarQueryParams.Add("model.countryCode", parameterToString(localVarOptionals.ModelCountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModelCulture.IsSet() {
		localVarQueryParams.Add("model.culture", parameterToString(localVarOptionals.ModelCulture.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []FullProductViewModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Get a listing of all available sub categories
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductGetSubCategoriesOpts - Optional Parameters:
     * @param "CartType" (optional.String) -
     * @param "CountryCode" (optional.String) -
     * @param "Culture" (optional.String) -

@return []SubMenuBlockModel
*/

type ProductApiProductGetSubCategoriesOpts struct {
	CartType    optional.String
	CountryCode optional.String
	Culture     optional.String
}

func (a *ProductApiService) ProductGetSubCategories(ctx context.Context, localVarOptionals *ProductApiProductGetSubCategoriesOpts) ([]SubMenuBlockModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []SubMenuBlockModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/sub-categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CartType.IsSet() {
		localVarQueryParams.Add("cartType", parameterToString(localVarOptionals.CartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CountryCode.IsSet() {
		localVarQueryParams.Add("countryCode", parameterToString(localVarOptionals.CountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Culture.IsSet() {
		localVarQueryParams.Add("culture", parameterToString(localVarOptionals.Culture.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []SubMenuBlockModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Invalidates the local cache
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *ProductApiService) ProductInvalidateCache(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/invalidate-cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProductApiService Search products by keyword
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProductApiProductSearchProductOpts - Optional Parameters:
     * @param "CountryCode" (optional.String) -
     * @param "Culture" (optional.String) -
     * @param "CartType" (optional.String) -
     * @param "SearchTerm" (optional.String) -

@return ProductSearchViewModel
*/

type ProductApiProductSearchProductOpts struct {
	CountryCode optional.String
	Culture     optional.String
	CartType    optional.String
	SearchTerm  optional.String
}

func (a *ProductApiService) ProductSearchProduct(ctx context.Context, localVarOptionals *ProductApiProductSearchProductOpts) (ProductSearchViewModel, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ProductSearchViewModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/products/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CountryCode.IsSet() {
		localVarQueryParams.Add("countryCode", parameterToString(localVarOptionals.CountryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Culture.IsSet() {
		localVarQueryParams.Add("culture", parameterToString(localVarOptionals.Culture.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CartType.IsSet() {
		localVarQueryParams.Add("cartType", parameterToString(localVarOptionals.CartType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SearchTerm.IsSet() {
		localVarQueryParams.Add("searchTerm", parameterToString(localVarOptionals.SearchTerm.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ProductSearchViewModel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
